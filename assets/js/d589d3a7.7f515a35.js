"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[162],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var s=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=s.createContext({}),p=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return s.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},u=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=p(n),h=i,m=u["".concat(l,".").concat(h)]||u[h]||c[h]||a;return n?s.createElement(m,o(o({ref:t},d),{},{components:n})):s.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var p=2;p<a;p++)o[p]=n[p];return s.createElement.apply(null,o)}return s.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9390:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>p});var s=n(7462),i=(n(7294),n(3905));const a={slug:"/"},o=void 0,r={unversionedId:"getting-started",id:"getting-started",title:"getting-started",description:"Getting Started",source:"@site/docs/getting-started.md",sourceDirName:".",slug:"/",permalink:"/workshop-starter/",draft:!1,tags:[],version:"current",frontMatter:{slug:"/"},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/workshop-starter/"}},l={},p=[{value:"Getting Started",id:"getting-started",level:2},{value:"Create Nest Application",id:"create-nest-application",level:3},{value:"Configure Cypress",id:"configure-cypress",level:3},{value:"Getting Missions",id:"getting-missions",level:2},{value:"Nest Missions Controller",id:"nest-missions-controller",level:3},{value:"Nest Missions Service",id:"nest-missions-service",level:3},{value:"Get Single Mission",id:"get-single-mission",level:2},{value:"Add Mission",id:"add-mission",level:2},{value:"Update &amp; Delete Missions",id:"update--delete-missions",level:3},{value:"Seeding the Database",id:"seeding-the-database",level:2},{value:"Protecting Routes",id:"protecting-routes",level:2},{value:"Validation",id:"validation",level:2},{value:"Exclude properties",id:"exclude-properties",level:2}],d={toc:p};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,s.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"getting-started"},"Getting Started"),(0,i.kt)("p",null,"Greetings, friend! In this tutorial, we are going to cover creating an API using\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://nestjs.com"},"NestJS")," framework. Along the way, we will build out the\napplication using tests with ",(0,i.kt)("a",{parentName:"p",href:"https://cypress.io"},"Cypress")," and the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/filiphric/cypress-plugin-api"},"Cypress API Plugin"),"."),(0,i.kt)("p",null,"If you are not familiar with NestJS, it is a Node based framework heavily\ninfluenced by Angular and is great for building any type of server side\napplication with. What I like about Nest is that it provides building blocks\n(similar to those found in Angular) for creating applications. This helps those\nwho are already familiar with Nest and how it works to jump from project to\nproject and know roughly how things already work."),(0,i.kt)("p",null,"Cypress is typically known for end-to-end testing web applications, as well as\ncomponent testing. With the Cypress API Plugin, we can use Cypress to test our\nbackend applications as well. The plugin provides a nice interface that shows\nthe results from each API call. Typically I would reach for something like\nPostman to use when I develop APIs, but with Cypress, I can nearly replace\nPostman and have a nice suite of automated tests to go along with it when I'm\ndone."),(0,i.kt)("p",null,"For this tutorial, we are creating an mission board for a fictional agency known\nas Cypress Heroes. This board will feature a list of missions that our heroes\ncan partake in. We'll be able to get, create, update, and delete missions in the\nboard. Yes, its pretty much a todo list, but its much cooler because, you know,\nsuper heroes."),(0,i.kt)("p",null,"To get started, you will need to have a relatively newer of Node installed and a\ncode editor (like VS Code)."),(0,i.kt)("h3",{id:"create-nest-application"},"Create Nest Application"),(0,i.kt)("p",null,"The first thing we will do is install the Nest CLI tool:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm i -g @nestjs/cli\n")),(0,i.kt)("p",null,"Next, use the CLI to create a new application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nest new cypress-heroes-api\n")),(0,i.kt)("p",null,"When prompted, select NPM as your package manager."),(0,i.kt)("p",null,"Go into the newly created ",(0,i.kt)("strong",{parentName:"p"},"cypress-heroes-api")," directory and install Cypress\nand the plugin:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm i -D cypress cypress-plugin-api\n")),(0,i.kt)("p",null,"Next, open the project in your code editor (we'll be using VS Code in the\ntutorial):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"code .\n")),(0,i.kt)("h3",{id:"configure-cypress"},"Configure Cypress"),(0,i.kt)("p",null,"Before we start working on the API, let's get Cypress up and running and write\nour first test. The test won't pass yet, but that's okay."),(0,i.kt)("p",null,"Launch Cypress:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npx cypress open\n")),(0,i.kt)("p",null,"Select End-to-End testing, and go through the next few steps. Cypress will\nconfigure your project by creating all the files necessary for it to run. While\nwe won't be doing end-to-end testing exactly, its the most appropriate place to\ndo API testing."),(0,i.kt)("p",null,"After the setup is done, update the ",(0,i.kt)("strong",{parentName:"p"},"cypress.config.ts")," file to add the\n",(0,i.kt)("inlineCode",{parentName:"p"},"baseUrl"),' option. We\'ll set it to "http://localhost:3000", which is what our\nNest application will serve the API on locally during development.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=cypress.config.ts",title:"cypress.config.ts"},"e2e: {\n  // highlight-next-line\n  baseUrl: 'http://localhost:3000',\n  setupNodeEvents(on, config) {\n    // implement node event listeners here\n  },\n},\n")),(0,i.kt)("p",null,"While we are at it, we will import the ",(0,i.kt)("inlineCode",{parentName:"p"},"cypress-plugin-api")," package into the\n",(0,i.kt)("strong",{parentName:"p"},"cypress/support/e2e.ts")," so it is available to use in our specs. Throw the\nfollowing towards the top of the file with any other imports:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=cypress/support/e2e.ts",title:"cypress/support/e2e.ts"},"import 'cypress-plugin-api';\n")),(0,i.kt)("p",null,"Now if you go back to Cypress, you'll see a warning that it can't verify the\nserver is running. This is just a little hint that we haven't started up our\nserver yet. Let's go ahead and do so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run start:dev\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"By this time, you will probably need to open several command windows or tabs to\nrun Cypress and Nest at the same time. In VS Code, I like to run Nest in a\n[JavaScript Debug\nTerminal(",(0,i.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_javascript-debug-terminal"},"https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_javascript-debug-terminal"),"),\nwhich will attach the debugger to the process automatically.")),(0,i.kt)("p",null,'Go back to Cypress, and hit the "try again" button on the section that warned us\nabout the server not running. It should go away, and you can hit "Start E2E\nTesting".'),(0,i.kt)("p",null,'Hit the "Create new empty spec" button and name the spec ',(0,i.kt)("strong",{parentName:"p"},"missions.cy.ts")," and\nrun it. This will create a default spec that simply visits a test site, but\nwe'll soon update it to contain all the tests we write for the missions API."),(0,i.kt)("p",null,"Open up the ",(0,i.kt)("strong",{parentName:"p"},"cypress/e2e/missions.cy.ts")," file and replace its contents with\nthe following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=cypress/e2e/missions.cy.ts",title:"cypress/e2e/missions.cy.ts"},"describe('missions api', () => {\n  it('should get missions', () => {\n    cy.api('/missions').as('response');\n    cy.get('@response').its('status').should('equal', 200);\n  });\n});\n")),(0,i.kt)("p",null,"Our first test (denoted in the ",(0,i.kt)("inlineCode",{parentName:"p"},"it()")," block) will use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.api()")," method\n(provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"cypress-plugin-api"),' package) to make a request to the\n"/missions" endpoint. We\'ll use the\n',(0,i.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/as"},(0,i.kt)("inlineCode",{parentName:"a"},"as()"))," method to\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/core-concepts/variables-and-aliases"},"alias")," the\nresult of the request. Aliasing in Cypress is how we store variables so we can\naccess them later."),(0,i.kt)("p",null,"Which is exactly what we do on the next line. The ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.get('@response')")," call\nget's the response variable, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"its(status)"),' call gets the status property\non the response object. This is the HTTP status code returned back from the API.\nIn the test, we want to verify that the code returned back 200, for a successful\ncall. We might consider this the "it works!" of API tests.'),(0,i.kt)("p",null,"Save the spec and go back to the Cypress test browser. The spec will fail, but\nwe expected it to since we haven't implemented any of the API as of yet. Let's\ndo so now!"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"The Missions API Spec Failed",src:n(2104).Z,width:"2560",height:"1440"})),(0,i.kt)("h2",{id:"getting-missions"},"Getting Missions"),(0,i.kt)("h3",{id:"nest-missions-controller"},"Nest Missions Controller"),(0,i.kt)("p",null,"Now, let's start to build out the API. The first thing we will need is a Nest\ncontroller. Controller's are responsible for listening and responding to HTTP\nrequests. We can use the Nest CLI to generate a missions controller for us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nest g controller missions\n")),(0,i.kt)("p",null,"Now we have a basic controller scaffolded at\n",(0,i.kt)("strong",{parentName:"p"},"src/missions/missions.controller.ts"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.controller.ts",title:"missions.controller.ts"},"import { Controller } from '@nestjs/common';\n\n@Controller('missions')\nexport class MissionsController {}\n")),(0,i.kt)("p",null,"Controllers are plain JavaScript objects that are decorated with the\n",(0,i.kt)("inlineCode",{parentName:"p"},"@Controller")," decorator. The decorator adds some meta-data to the class that the\nframework uses to determine which controller will response to which HTTP\nrequest. In this case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsController"),' will response to any requests\nthat go to the "/missions" route (denoted by the parameter passed into the\ncontroller).'),(0,i.kt)("p",null,"The Nest CLI also modified the ",(0,i.kt)("strong",{parentName:"p"},"app.module.ts")," file for us, adding in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsController")," to the controllers array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=app.module.ts",title:"app.module.ts"},"@Module({\n  imports: [],\n  // highlight-next-line\n  controllers: [AppController, MissionsController],\n  providers: [AppService],\n})\nexport class AppModule {}\n")),(0,i.kt)("p",null,"Our first API will be to return back a list of missions. Let's start simple and\nreturn back a hard coded array:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@Get()\ngetList() {\n  return [\n    {\n      description: 'save the world',\n      complete: false,\n    },\n  ];\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Get()")," decorator instructs Nest that the ",(0,i.kt)("inlineCode",{parentName:"p"},"getList()")," method will respond\nto HTTP GET methods. What gets returned from the method is what will be in the\nresponse's body, automatically serialized as JSON. We can return something\nsynchronous like we do above, or if we return an async value (like a promise or\nRXJS observable), then the value yielded from the async response will be in the\nbody."),(0,i.kt)("p",null,"Back in the test runner, and hit the Run all specs button to try the test again.\nThis time the test will pass:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Run all tests",src:n(1637).Z,width:"3584",height:"2082"})),(0,i.kt)("p",null,"On the right, we can see the results and browse through the returned response\n(our hard coded missions array), the headers, and cookies."),(0,i.kt)("p",null,"Great stuff, but we normally don't return back hard coded data. Much like\nAngular, Nest has the concept of services which are responsible for any type of\nbusiness logic and communicating with other systems."),(0,i.kt)("h3",{id:"nest-missions-service"},"Nest Missions Service"),(0,i.kt)("p",null,"Instead of using the hard coded array, we will create a service that will be\nresponsible for handling all the missions data. Run the following command to\ncreate a new service from the Nest CLI:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nest g service missions\n")),(0,i.kt)("p",null,"This will create a ",(0,i.kt)("strong",{parentName:"p"},"missions.service.ts")," file for us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/missions/missions.service.ts",title:"src/missions/missions.service.ts"},"import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class MissionsService {}\n")),(0,i.kt)("p",null,"Like a controller, a service is a JavaScript class marked with a decorator.\nAngular devs will find Nest services very similar to their NG counterparts.\nUnlike an Angular service, though, Nest doesn't have a ",(0,i.kt)("inlineCode",{parentName:"p"},"providedIn")," option, so\nthe service has to be registered in a module (which the CLI added it to the app\nmodule for us already)."),(0,i.kt)("p",null,"Let's refactor the code and return the missions from the service instead. First\nupdate the service with the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/missions/missions.service.ts",title:"src/missions/missions.service.ts"},"import { Injectable } from '@nestjs/common';\n\nexport interface Mission {\n  id?: number;\n  description: string;\n  complete: boolean;\n}\n\nconst defaultMission: Mission = {\n  id: 1,\n  description: 'save the galaxy',\n  complete: false,\n};\n\n@Injectable()\nexport class MissionsService {\n  missions: Mission[] = [{ ...defaultMission }];\n\n  getList() {\n    return this.missions;\n  }\n}\n")),(0,i.kt)("p",null,"Above, we first define a ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," interface that will be the data structure for\nthe missions. It will have an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," with an optional type of number, a\n",(0,i.kt)("inlineCode",{parentName:"p"},"description")," with a type string, a ",(0,i.kt)("inlineCode",{parentName:"p"},"complete")," with a type of boolean, and a\n",(0,i.kt)("inlineCode",{parentName:"p"},"created")," with a type of string that will contain a ISO date string of when the\nmission was added."),(0,i.kt)("p",null,"Next, we define a default mission that we will use to seed the database with.\nSpeaking of databases, to keep things simple we won't be using a real one here,\nbut instead we'll be using an in memory array that I'll lovingly refer to as\nArrayDB\u2122\ufe0f. Therefore, each time we update the Nest app and it\nrecompiles/relaunches, we'll loose any modifications. Thus, we'll set the array\nto contain the ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultMission")," when the services initializes. In a real app, we\nwould instead call into a data layer or ORM like ",(0,i.kt)("a",{parentName:"p",href:"https://typeorm.io/"},"TypeORM"),"\nor ",(0,i.kt)("a",{parentName:"p",href:"https://www.prisma.io/"},"Prisma")," to manage data."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"getList()")," method returns everything that is currently in the array."),(0,i.kt)("p",null,"Next, update the controller to get a reference to the service via\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/fundamentals/custom-providers#di-fundamentals"},"dependency injection"),"\n(just like Angular!). Then, update the ",(0,i.kt)("inlineCode",{parentName:"p"},"getList")," method to return the call from\nthe service instead of the hard coded array:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, Get } from '@nestjs/common';\nimport { MissionsService } from './missions.service';\n\n@Controller('missions')\nexport class MissionsController {\n  constructor(private missionsService: MissionsService) {}\n\n  @Get()\n  getList() {\n    return this.missionsService.getList();\n  }\n}\n")),(0,i.kt)("p",null,'Now we can rerun the test, and if we see the description of the mission come\nback as "save the galaxy" (versus "save the world"), we know the API is\nreturning data back from the service.'),(0,i.kt)("h2",{id:"get-single-mission"},"Get Single Mission"),(0,i.kt)("p",null,"Next, let's update the API to be able to retrieve a specific mission via it's\n",(0,i.kt)("inlineCode",{parentName:"p"},"id"),". We'll specify the id via a route param appended to the end of the URL like\n'/missions/1'."),(0,i.kt)("p",null,"First, add a test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"it('should get single mission', () => {\n  cy.api('/missions/1').as('response');\n  cy.get('@response').its('status').should('equal', 200);\n  cy.get('@response').its('body').should('include', {\n    id: 1,\n    description: 'take out the trash',\n    complete: false,\n  });\n});\n")),(0,i.kt)("p",null,"This test starts off much like the last one, except we specify we want to pull\nback the mission with the id of 1 (the default mission). After we assert the\nrequest comes back successfully (by ensuring the status code is 200), we check\nthat the body of the response includes the mission we expect."),(0,i.kt)("p",null,"Update the service to add a get method, which will use ArrayDB\u2122\ufe0f's find method\nto retrieve the mission if it exists, else it will just return undefined:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.service.ts",title:"missions.service.ts"},"get(id: number) {\n  const mission = this.missions.find(x => x.id === id);\n  return mission;\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.controller.ts",title:"missions.controller.ts"},"@Get(':id')\nget(@Param('id', ParseIntPipe) id: number) {\n  return this.missionsService.get(id);\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'ParseIntPipe is imported from "@nestjs/common"')),(0,i.kt)("p",null,"Let's go over what's new here. First, the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Get()")," decorator is taking in a\nstring param, which is an additional path in the URL that the controller should\nlook for in addition to the URL prefix that's supplied in the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Controller()"),'\ndecorator on the class. Here, we are specifying ":id". When we prepend a colon\nto the string like we did, we are saying we are looking for a dynamic portion of\nthe string, and when matched, store it in a variable which is named by what\ncomes after the colon.'),(0,i.kt)("p",null,'In our case, we are going to store the mission id (as our path is\n/missions/{id}), into a variable named "id". In the ',(0,i.kt)("inlineCode",{parentName:"p"},"get()")," method, we have a\nmethod argument named ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", but before it we are using the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Param()")," decorator.\nThis decorator instructs Nest to look for the variable name passed into it and\nbind it to the argument."),(0,i.kt)("p",null,"Since parameters coming in from the URL are all strings, we can use a mechanism\nbuilt into Nest known as ",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/pipes"},"pipes")," to transform the\nvalue on the way in. Above, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ParseIntPipe")," to convert the value to a\nnumber, which our service will need when looking up the mission."),(0,i.kt)("p",null,"Next, let's add a test that shows when we request a mission that doesn't exist,\nthat it the API should return a 404 not found error. We'll do so by passing in\nan id of 100 to the missions endpoint:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"it('should throw 404 if single mission is not found', () => {\n  cy.api({\n    url: '/missions/100',\n    failOnStatusCode: false,\n  }).as('response');\n  cy.get('@response').its('status').should('equal', 404);\n});\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"By default, calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.api()")," will fail if they don't return back a success\nstatus code in the 200 range. Above, we are expecting the code to be 404, so\nwe turn ",(0,i.kt)("inlineCode",{parentName:"p"},"failOnStatusCode")," to false in the options so it won't fail.")),(0,i.kt)("p",null,"If you run the test, you will see it currently fails. Even though we don't get a\nmission back, the status code is 200."),(0,i.kt)("p",null,"Nest provides a\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/exception-filters#built-in-http-exceptions"},"set of exceptions"),"\nthat we can throw in certain scenarios to return back appropriate status codes.\nOne of which is the ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundException"),". We can throw this error in any place we\nlike in the app, and a global exception filter will catch it and return back a\nresponse with a 404 status code."),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsService"),", we will check to see if we find a mission when we\nquery ArrayDB\u2122\ufe0f for it. If we don't, we'll throw a ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundException")," and let\nNest handle the dirty work from there:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"get(id: number) {\n  const mission = this.missions.find((x) => x.id === id);\n  if (!mission) {\n    throw new NotFoundException();\n  }\n  return mission;\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundException"),' is imported from "@nestjs/common"')),(0,i.kt)("h2",{id:"add-mission"},"Add Mission"),(0,i.kt)("p",null,"Next up, let's add new missions to the list. To add a mission, we will use the\n\"POST\" HTTP method to the missions endpoint, and set the body of the request\nwith the new mission. We'll expect the result of the API request to be the new\nmission created."),(0,i.kt)("p",null,"Add the following test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"it('can add mission', () => {\n  const mission = {\n    description: 'test mission',\n    complete: false,\n  };\n  cy.api('POST', '/missions', mission).as('response');\n  cy.get('@response').its('status').should('equal', 201);\n  cy.get('@response').its('body').should('include', mission);\n});\n")),(0,i.kt)("p",null,"The only thing above we haven't yet seen above is passing the new mission as an\nobject to the third parameter of the ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.api()")," method. The api method will\nserialize that object as JSON and set it to the request's body, as well as set\nall the necessary headers."),(0,i.kt)("p",null,"Update the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsService")," to include the ",(0,i.kt)("inlineCode",{parentName:"p"},"addMission")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"add(mission: Mission) {\n  const newId = Math.max(...this.missions.map((x) => x.id)) + 1;\n  mission.id = newId;\n  this.missions.push(mission);\n  return mission;\n}\n")),(0,i.kt)("p",null,"Here, we take the new mission, and since ArrayDB\u2122\ufe0f doesn't have\nauto-incrementing ids, we need to calculate a new id on our own. After that, we\nuse the push method to add the new mission to the list then return it."),(0,i.kt)("p",null,"Next, add the controller method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=mission.controller.ts",title:"mission.controller.ts"},"@Post()\naddMission(@Body() mission: Mission) {\n  return this.missionsService.add(mission);\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Post and Body are imported from "@nestjs/common"')),(0,i.kt)("p",null,"There are a couple of new things to note above. First, the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Post()"),' decorator\nstates that this will be the method that will response to "POST" HTTP methods.'),(0,i.kt)("p",null,"Next, is the new ",(0,i.kt)("inlineCode",{parentName:"p"},"@Body()")," decorator. This instructs Nest to take the contents\nfrom the body of the request and serialize it into the parameter it is attached\nto. Hence, the mission variable will contain the new mission to add."),(0,i.kt)("p",null,"Run the add mission test again and you should see it pass with a 201 status\ncode, which represents a new entity was created as a result of the request."),(0,i.kt)("h3",{id:"update--delete-missions"},"Update & Delete Missions"),(0,i.kt)("p",null,"Now that we are starting to get the hang of this, let's bang out the last two\nmethods we are going to want, updating and deleting."),(0,i.kt)("p",null,"First the tests:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"it('should update mission', () => {\n  const mission = {\n    description: 'get cat out of tree',\n    complete: true,\n  };\n  cy.api({\n    url: '/missions/1',\n    method: 'PUT',\n    body: mission,\n  }).as('response');\n  cy.get('@response').its('status').should('equal', 200);\n  cy.get('@response').its('body').should('include', mission);\n});\n\nit('can delete mission', () => {\n  cy.api('DELETE', '/missions/1').as('response');\n  cy.get('@response').its('status').should('equal', 204);\n});\n")),(0,i.kt)("p",null,"The service code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.service.ts",title:"missions.service.ts"},"update(id: number, mission: Mission) {\n  mission.id = id;\n  this.missions = this.missions.map((x) => {\n    return x.id === id ? mission : x;\n  });\n  return this.get(id);\n}\n\ndelete(id: number) {\n  this.missions = this.missions.filter((x) => x.id !== id);\n}\n")),(0,i.kt)("p",null,"And the controller code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.controller.ts",title:"missions.controller.ts"},"@Put(':id')\nupdateMission(\n  @Param('id', ParseIntPipe) id: number,\n  @Body() mission: Mission,\n) {\n  return this.missionsService.update(id, mission);\n}\n\n@Delete(':id')\n@HttpCode(204)\ndelete(@Param('id', ParseIntPipe) id: number) {\n  this.missionsService.delete(id);\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Put, Delete, and HttpCode are imported from "@nestjs/common"')),(0,i.kt)("p",null,"Pretty standard stuff that you've seen already. The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Put()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@Delete()"),"\ndecorators make these methods listen for their respective HTTP methods."),(0,i.kt)("p",null,"The only new thing is the ",(0,i.kt)("inlineCode",{parentName:"p"},"@HttpCode()")," decorator on the ",(0,i.kt)("inlineCode",{parentName:"p"},"delete()"),' method. By\ndefault, Nest will return back a 200 status code for all HTTP methods except for\n"POST", which it will return 201 for. To change the default, use this decorator.\nIn our case, we are using status code 204, which means we are not returning any\ncontent and that is to be expected. Notice how we are not returning anything\nfrom this method.'),(0,i.kt)("p",null,"The first time we run these tests, they will pass. However, the next run we will\nget some failures. This is because some of the tests are expecting the database\nto be in its default state, but we are now modifying it with the add, update,\nand delete methods."),(0,i.kt)("p",null,"It is best practice to not have one test reflect the outcomes of another test,\nbut that is exactly what we are doing currently. What can we do about it?"),(0,i.kt)("p",null,"One method is to reset the database into a known state before each test is run.\nThis is often difficult to do, but because our database is so small, we have\nthat luxury. Let's see how we can accomplish that."),(0,i.kt)("h2",{id:"seeding-the-database"},"Seeding the Database"),(0,i.kt)("p",null,"The technique we are going to use here is having a method in our API that will\nreset the database back to its initial state. The first thing we will do is have\na method in the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsService")," to reset the ArrayDB\u2122\ufe0f:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.service.ts",title:"missions.service.ts"},"reset() {\n  this.missions = [{ ...defaultMission }];\n}\n")),(0,i.kt)("p",null,"Above, we are just overrriding the array by setting it to an array that only\ncontains the ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultMission"),", just like when the API first initializes."),(0,i.kt)("p",null,"Next, we'll create a method in the controller our tests can call to reset:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.controller.ts",title:"missions.controller.ts"},"@Post('/reset')\nreset() {\n  if (process.env.NODE_ENV === 'test' || process.env.NODE_ENV === 'dev') {\n    this.missionsService.reset();\n  }\n}\n")),(0,i.kt)("p",null,'We\'ll make the method respond to a "POST" request since its changing state\ninside the system. We also check to make sure that the environment is either is\n"test" or "dev", as we don\'t want to call this method available in production.\nWe need to update the "start:dev" script in the package file to set the Node\nenvironment.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:"package.json","package.json":!0},'"start:dev": "NODE_ENV=dev nest start --watch",\n')),(0,i.kt)("p",null,"Make sure you restart the Nest server so the change can take affect."),(0,i.kt)("p",null,"A bit later, we will take a look at how to secure this endpoint even more so the\ncalling API will need a token in order to call it."),(0,i.kt)("p",null,"Back in the tests, we want to make sure that we reseed the database before each\ntest is ran. We can use the\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/core-concepts/writing-and-organizing-tests#Test-Structure"},(0,i.kt)("inlineCode",{parentName:"a"},"beforeEach")),"\ntest hook for that. Add the following block inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"describe")," block before\nthe first test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"beforeEach(() => {\n  cy.request({\n    log: false,\n    method: 'POST',\n    url: '/missions/reset',\n  });\n  cy.log('seeding db');\n});\n")),(0,i.kt)("p",null,"Above, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.request()")," command, which is the built in command for\nmaking API requests in Cypress. We set logging to false so it doesn't get too\nnoisy in the command log, but also output a small \"seeding db\" message so we\nknow it's happening."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The technique above is just one strategy for seeding a database for testing,\nthere are many ways to do so and some will be more appropriate for others in\nyour app. See the Cypress guide on\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/end-to-end-testing/testing-your-app#Seeding-data"},"seeding data"),"\nfor some more info on the subject.")),(0,i.kt)("p",null,"Now you should be able to run the tests over and over again without the state of\nthe previous test getting in the way."),(0,i.kt)("h2",{id:"protecting-routes"},"Protecting Routes"),(0,i.kt)("p",null,"Above in the ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()")," method on the controller, we put one safe guard in place\nto make sure the app wasn't in production when trying to reseed the database.\nLet's add another layer of security by requiring the calling client provides a\ntoken to prove they have access to do a db reseed."),(0,i.kt)("p",null,"To accomplish validating this token, we will use a\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/guards"},"Nest Guard"),", which is a piece of middleware\nwhich Nest can invoke for each HTTP request before passing the request on to the\ncontrollers."),(0,i.kt)("p",null,"First, we will use the CLI to create a guard for us. We'll call it\n",(0,i.kt)("inlineCode",{parentName:"p"},"TestEnvOnly"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nest g guard TestEnvOnly\n")),(0,i.kt)("p",null,"A guard is another JavaScript class that has one required method, ",(0,i.kt)("inlineCode",{parentName:"p"},"canActivate"),".\nThis method determines if the request should be able to proceed through the\npipeline or not by return a boolean or a promise/observable that yields a\nboolean value."),(0,i.kt)("p",null,"Update the contents of the newly created\n",(0,i.kt)("strong",{parentName:"p"},"src/test-env-only/test-env-only.guard.ts")," file with the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/test-env-only/test-env-only.guard.ts",title:"src/test-env-only/test-env-only.guard.ts"},"import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class TestEnvOnlyGuard implements CanActivate {\n  canActivate(\n    context: ExecutionContext\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    const request = context.switchToHttp().getRequest();\n\n    if (!(process.env.NODE_ENV === 'test' || process.env.NODE_ENV === 'dev')) {\n      return false;\n    }\n\n    if (request.headers.authorization !== 'resetcreds') {\n      return false;\n    }\n\n    return true;\n  }\n}\n")),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"canActivate")," method, the first thing we do is grab access to the HTTP\nrequest."),(0,i.kt)("p",null,"Next, we move the code to check the environment from the controller ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()"),"\nmethod, and then we check that an ",(0,i.kt)("inlineCode",{parentName:"p"},"authorization")," header as the correct token.\nWe are using a simple string here, but this token could be more complex like a\nJWT or API key that could be validated."),(0,i.kt)("p",null,"If either of the above checks don't pass, we return false, which instructs Nest\nto end the request and send back a 403 Forbidden status code. If they are both\ngood, then we return true and the request will continue to the controller."),(0,i.kt)("p",null,"Unlike when we generated the Nest service and controller, the guard did not\nautomatically get wired up for us in the app module. That's because the way you\nuse guards can either be globally or more granular. We only want to apply the\nguard to the ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()")," method, so we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@UseGuards()")," decorator and\npass the ",(0,i.kt)("inlineCode",{parentName:"p"},"TestOnlyGuard")," as a parameter to it:"),(0,i.kt)("p",null,"a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@UseGuards(TestEnvOnlyGuard)\n@Post('/reset')\nreset() {\n  this.missionsService.reset();\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'UseGuards is imported from "@nestjs/common" TestEnvOnlyGuard is imported from\n"src/test-env-only/test-env-only.guard"')),(0,i.kt)("p",null,"Nest will now use the guard for each request coming into this method."),(0,i.kt)("p",null,'If you try the tests again, you will see them fail because we aren\'t passing the\ntoken on the "reset" request in the ',(0,i.kt)("inlineCode",{parentName:"p"},"beforeEach"),". Update the block to do so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"beforeEach(() => {\n  cy.request({\n    log: false,\n    method: 'POST',\n    url: '/missions/reset',\n    headers: {\n      Authorization: 'resetcreds',\n    },\n  });\n  cy.log('seeding db');\n});\n")),(0,i.kt)("p",null,"Visit the Nest docs on more ways to bind guards to your application."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"We use a guard here to protect our database, but you will also use guards to\nimplement authentication to validate who users are. They even include some built\nin ones to get you up and running quickly. Visit their\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/security/authentication"},"authentication")," guide for more\ninfo.")),(0,i.kt)("h2",{id:"validation"},"Validation"),(0,i.kt)("p",null,"We pretty much have a working API to manage our missions, however, we haven't\ndone anything yet to make sure that the data coming into our system is valid.\nValidating data coming into your system is important because it helps ensure the\nintegrity of your database, helps with security, and provides a better developer\nexperience for those consuming your API."),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," model is fairly simple, but lets add some validation to it to\nensure that any time one is added or updated, that we make sure its good."),(0,i.kt)("p",null,"First up, a new test to validate that trying to create an invalid module returns\nback a 400 Bad Request status code, which signifies to the user they did\nsomething wrong with the request. The body of the response will contain helpful\nmessages on what went wrong:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"it('when adding an invalid mission, get 400 error', () => {\n  const mission = {};\n  cy.api({\n    method: 'POST',\n    url: '/missions',\n    body: mission,\n    failOnStatusCode: false,\n  }).as('response');\n  cy.get('@response').its('status').should('equal', 400);\n  cy.get('@response')\n    .its('body')\n    .should('deep.include', {\n      message: [\n        'description must not be an empty string',\n        'description must be a string',\n        'complete must be a boolean',\n      ],\n    });\n});\n")),(0,i.kt)("p",null,"We will be using a couple of helper libraries to help accomplish this.\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/typestack/class-validator"},"Class Validator")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/typestack/class-transformer"},"Class Transformer")," are two\nlibraries that fit well in the Nest ecosystem. They allow us to use TypeScript\ndecorators to annotate our models and provide validation logic declaratively."),(0,i.kt)("p",null,"We need to install the libraries. Run the following from your terminal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm i class-transformer class-validator\n")),(0,i.kt)("p",null,"Currently our ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," model is an interface. In order to annotate it with\ndecorators, we will need to convert it to a class instead and refactor some\ncode."),(0,i.kt)("p",null,"Create a new file at ",(0,i.kt)("strong",{parentName:"p"},"src/missions/Mission.ts")," and paste the following into\nit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/missions/Mission.ts",title:"src/missions/Mission.ts"},"export class Mission {\n  id?: number;\n  description: string;\n  complete: boolean;\n  created: string;\n\n  constructor(partial: Partial<Mission>) {\n    Object.assign(this, partial);\n  }\n}\n")),(0,i.kt)("p",null,"update missions and reset to use class in service:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"//missions\nmissions: Mission[] = [new Mission(defaultMission)];\n\n//reset\nreset() {\n  this.missions = [new Mission(defaultMission)];\n}\n")),(0,i.kt)("p",null,"update Mission class to use decorators"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { IsString, IsNotEmpty, IsBoolean } from 'class-validator';\n\nexport class Mission {\n  id?: number;\n\n  @IsString({ message: 'description must be a string' })\n  @IsNotEmpty({ message: 'description must not be an empty string' })\n  description: string;\n\n  @IsBoolean({ message: 'complete must be a boolean' })\n  complete: boolean;\n  created: string;\n}\n")),(0,i.kt)("p",null,"use validationpipe in app.module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  provide: APP_PIPE,\n  useValue: new ValidationPipe({ transform: true }),\n},\n")),(0,i.kt)("p",null,"delete parseint pipe from controller because the validator will now convert\ntypes automatically"),(0,i.kt)("h2",{id:"exclude-properties"},"Exclude properties"),(0,i.kt)("p",null,"add check to get single mission test to check for created:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"cy.get('@response').its('body.created').should('be.undefined');\n")),(0,i.kt)("p",null,"Add exclude decorator to created prop on class"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Exclude } from 'class-transformer';\n\n//prop\n@Exclude()\ncreated: string;\n")),(0,i.kt)("p",null,"show fail, then add ClassSerializerInterceptor to module providers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  provide: APP_INTERCEPTOR,\n  useClass: ClassSerializerInterceptor,\n},\n")))}c.isMDXComponent=!0},2104:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/missions_fail-a136ff53c9d432e64b1c7ea01ab2672c.jpg"},1637:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/run_all_tests-9bab9f0223002d2b67dd40d8278311fa.jpg"}}]);