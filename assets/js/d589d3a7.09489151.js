"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[162],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var s=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=s.createContext({}),p=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return s.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},h=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),h=p(n),u=i,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||a;return n?s.createElement(m,o(o({ref:t},d),{},{components:n})):s.createElement(m,o({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var p=2;p<a;p++)o[p]=n[p];return s.createElement.apply(null,o)}return s.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9390:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>p});var s=n(7462),i=(n(7294),n(3905));const a={title:"NestJS API with Cypress API Testing",slug:"/"},o=void 0,r={unversionedId:"getting-started",id:"getting-started",title:"NestJS API with Cypress API Testing",description:"Getting Started",source:"@site/docs/getting-started.md",sourceDirName:".",slug:"/",permalink:"/cypress-api-testing/",draft:!1,tags:[],version:"current",frontMatter:{title:"NestJS API with Cypress API Testing",slug:"/"},sidebar:"tutorialSidebar"},l={},p=[{value:"Getting Started",id:"getting-started",level:2},{value:"Create Nest Application",id:"create-nest-application",level:3},{value:"Configure Cypress",id:"configure-cypress",level:3},{value:"Getting Missions",id:"getting-missions",level:2},{value:"Nest Missions Controller",id:"nest-missions-controller",level:3},{value:"Nest Missions Service",id:"nest-missions-service",level:3},{value:"Get Single Mission",id:"get-single-mission",level:2},{value:"Add Mission",id:"add-mission",level:2},{value:"Update &amp; Delete Missions",id:"update--delete-missions",level:2},{value:"Seeding the Database",id:"seeding-the-database",level:2},{value:"Protecting Routes",id:"protecting-routes",level:2},{value:"Validation",id:"validation",level:2},{value:"Exclude properties",id:"exclude-properties",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:p};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,s.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"getting-started"},"Getting Started"),(0,i.kt)("p",null,"Greetings, friend! This tutorial will cover creating an API using\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://nestjs.com"},"NestJS")," framework. Along the way, we will build out the\napplication using tests with ",(0,i.kt)("a",{parentName:"p",href:"https://cypress.io"},"Cypress")," and the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/filiphric/cypress-plugin-api"},"Cypress API Plugin"),"."),(0,i.kt)("p",null,"If you are unfamiliar with NestJS, it is a Node-based framework heavily\ninfluenced by Angular and is great for building any server-side\napplication. What I like about Nest is that it provides building blocks\n(similar to those found in Angular) for creating applications. This helps those\nfamiliar with Nest and how it works to jump from project to\nproject and know roughly how things already work."),(0,i.kt)("p",null,"Cypress is typically known for end-to-end testing web applications, as well as\ncomponent testing. With the Cypress API Plugin, we can also use Cypress to test our\nbackend applications. The plugin provides a nice interface showing each API call's results. Typically I would reach for something like\nPostman to use when I develop APIs, but with Cypress, I can nearly replace\nPostman and have a nice suite of automated tests to go along with it when I'm\ndone."),(0,i.kt)("p",null,"For this tutorial, we are creating a mission board for a fictional agency called Cypress Heroes. This board will feature a list of our heroes' missions. We'll be able to get, create, update, and delete missions on the\nboard. Yes, it's a to-do list, but it's much cooler because, you know,\nsuperheroes."),(0,i.kt)("p",null,"To get started, you will need to have a relatively newer version of Node installed and a\ncode editor (like VS Code)."),(0,i.kt)("h3",{id:"create-nest-application"},"Create Nest Application"),(0,i.kt)("p",null,"The first thing we will do is install the Nest CLI tool:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm i -g @nestjs/cli\n")),(0,i.kt)("p",null,"Next, use the CLI to create a new application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nest new cypress-heroes-api\n")),(0,i.kt)("p",null,"When prompted, select NPM as your package manager."),(0,i.kt)("p",null,"Go into the newly created ",(0,i.kt)("strong",{parentName:"p"},"cypress-heroes-api")," directory and install Cypress\nand the plugin:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm i -D cypress cypress-plugin-api\n")),(0,i.kt)("p",null,"Next, open the project in your code editor (we'll be using VS Code in the\ntutorial):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"code .\n")),(0,i.kt)("h3",{id:"configure-cypress"},"Configure Cypress"),(0,i.kt)("p",null,"Before we start working on the API, let's get Cypress up and running and write\nour first test. The test won't pass yet, but that's okay."),(0,i.kt)("p",null,"Launch Cypress:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npx cypress open\n")),(0,i.kt)("p",null,"Select End-to-End testing, and go through the next few steps. Cypress will\nconfigure your project by creating all the files necessary for it to run. While\nwe won't be doing end-to-end testing exactly, it's the most appropriate place to\ndo API testing."),(0,i.kt)("p",null,"After the setup is done, update the ",(0,i.kt)("strong",{parentName:"p"},"cypress.config.ts")," file to add the\n",(0,i.kt)("inlineCode",{parentName:"p"},"baseUrl"),' option. We\'ll set it to "http://localhost:3000", which is what our\nNest application will serve the API locally during development.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=cypress.config.ts",title:"cypress.config.ts"},"e2e: {\n  // highlight-next-line\n  baseUrl: 'http://localhost:3000',\n  setupNodeEvents(on, config) {\n    // implement node event listeners here\n  },\n},\n")),(0,i.kt)("p",null,"While we are at it, we will import the ",(0,i.kt)("inlineCode",{parentName:"p"},"cypress-plugin-api")," package into the\n",(0,i.kt)("strong",{parentName:"p"},"cypress/support/e2e.ts")," so it is available to use in our specs. Throw the\nfollowing towards the top of the file with any other imports:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=cypress/support/e2e.ts",title:"cypress/support/e2e.ts"},"import 'cypress-plugin-api';\n")),(0,i.kt)("p",null,"If you go back to Cypress, you'll see a warning that it can't verify the\nserver is running. This hints that we still need to start up our\nserver. Let's go ahead and do so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm run start:dev\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"You will likely need to open several command windows or tabs to\nrun Cypress and Nest simultaneously. In VS Code, I like to run Nest in a\n",(0,i.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_javascript-debug-terminal"},"JavaScript Debug\nTerminal"),",\nwhich will attach the debugger to the process automatically.")),(0,i.kt)("p",null,'Go back to Cypress, and hit the "try again" button on the section that warned us\nabout the server not running. It should go away, and you can hit "Start E2E\nTesting".'),(0,i.kt)("p",null,'Hit the "Create new empty spec" button, name the spec ',(0,i.kt)("strong",{parentName:"p"},"missions.cy.ts"),", and\nrun it. This will create a default spec that visits a test site, but\nwe'll soon update it to contain all the tests we write for the missions API."),(0,i.kt)("p",null,"Open up the ",(0,i.kt)("strong",{parentName:"p"},"cypress/e2e/missions.cy.ts")," file and replace its contents with\nthe following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=cypress/e2e/missions.cy.ts",title:"cypress/e2e/missions.cy.ts"},"describe('missions api', () => {\n  it('should get missions', () => {\n    cy.api('/missions').as('response');\n    cy.get('@response').its('status').should('equal', 200);\n  });\n});\n")),(0,i.kt)("p",null,"Our first test (denoted in the ",(0,i.kt)("inlineCode",{parentName:"p"},"it()")," block) will use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.api()")," method\n(provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"cypress-plugin-api"),' package) to make a request to the\n"/missions" endpoint. We\'ll use the\n',(0,i.kt)("a",{parentName:"p",href:"https://docs.cypress.io/api/commands/as"},(0,i.kt)("inlineCode",{parentName:"a"},"as()"))," method to\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/core-concepts/variables-and-aliases"},"alias")," the\nresult of the request. Aliasing in Cypress is how we store variables to\naccess them later."),(0,i.kt)("p",null,"Which is exactly what we do on the next line. The ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.get('@response')")," call\nget's the response variable, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"its(status)"),' call gets the status property\non the response object. This is the HTTP status code returned back from the API.\nIn the test, we want to verify that the code returned 200 for a successful\ncall. We might consider this the "it works!" of API tests.'),(0,i.kt)("p",null,"Save the spec and go back to the Cypress test browser. The spec will fail, but\nwe expected it to since we have yet to implement any API. Let's\ndo so now!"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"The Missions API Spec Failed",src:n(8124).Z,width:"2560",height:"1440"})),(0,i.kt)("h2",{id:"getting-missions"},"Getting Missions"),(0,i.kt)("h3",{id:"nest-missions-controller"},"Nest Missions Controller"),(0,i.kt)("p",null,"Now, let's start to build out the API. The first thing we will need is a Nest\ncontroller. Controllers are responsible for listening and responding to HTTP\nrequests. We can use the Nest CLI to generate a missions controller for us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nest g controller missions\n")),(0,i.kt)("p",null,"Now we have a basic controller scaffolded at\n",(0,i.kt)("strong",{parentName:"p"},"src/missions/missions.controller.ts"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.controller.ts",title:"missions.controller.ts"},"import { Controller } from '@nestjs/common';\n\n@Controller('missions')\nexport class MissionsController {}\n")),(0,i.kt)("p",null,"Controllers are plain JavaScript objects that are decorated with the\n",(0,i.kt)("inlineCode",{parentName:"p"},"@Controller")," decorator. The decorator adds meta-data to the class that the\nframework uses to determine which controller will respond to which HTTP\nrequest. In this case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsController"),' will respond to requests\nthat go to the "/missions" route (denoted by the parameter passed into the\ncontroller).'),(0,i.kt)("p",null,"The Nest CLI also modified the ",(0,i.kt)("strong",{parentName:"p"},"app.module.ts")," file for us, adding in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsController")," to the controller's array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=app.module.ts",title:"app.module.ts"},"@Module({\n  imports: [],\n  // highlight-next-line\n  controllers: [AppController, MissionsController],\n  providers: [AppService],\n})\nexport class AppModule {}\n")),(0,i.kt)("p",null,"Our first API will be to return back a list of missions. Let's start simple and\nreturn back a hard-coded array:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@Get()\ngetList() {\n  return [\n    {\n      description: 'save the world',\n      complete: false,\n    },\n  ];\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Get()")," decorator instructs Nest that the ",(0,i.kt)("inlineCode",{parentName:"p"},"getList()")," method will respond\nto HTTP GET methods. What gets returned from the method is what will be in the\nresponse's body, automatically serialized as JSON. We can return something\nsynchronous as we do above, or if we return an async value (like a promise or\nRXJS observable), then the value yielded from the async response will be in the\nbody."),(0,i.kt)("p",null,'Back in the test runner, hit the "Run all specs" button to try the test again.\nThis time the test will pass:'),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Run all tests",src:n(7546).Z,width:"3584",height:"2082"})),(0,i.kt)("p",null,"On the right, we can see the results and browse through the returned response (our hard-coded missions array), the headers, and cookies."),(0,i.kt)("p",null,"Great stuff, but we normally don't return back hard coded data. Much like\nAngular, Nest has the concept of services that are responsible for any type of\nbusiness logic and communicating with other systems."),(0,i.kt)("h3",{id:"nest-missions-service"},"Nest Missions Service"),(0,i.kt)("p",null,"Instead of using the hard-coded array, we will create a service\nresponsible for handling all the mission data. Run the following command to\ncreate a new service from the Nest CLI:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nest g service missions\n")),(0,i.kt)("p",null,"This will create a ",(0,i.kt)("strong",{parentName:"p"},"missions.service.ts")," file for us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/missions/missions.service.ts",title:"src/missions/missions.service.ts"},"import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class MissionsService {}\n")),(0,i.kt)("p",null,"A service is a JavaScript class marked with a decorator like a controller.\nAngular devs will find Nest services very similar to their NG counterparts.\nUnlike an Angular service, though, Nest doesn't have a ",(0,i.kt)("inlineCode",{parentName:"p"},"providedIn")," option, so\nthe service has to be registered in a module (which the CLI already added to the app\nmodule for us)."),(0,i.kt)("p",null,"Let's refactor the code and return the missions from the service instead. First\nupdate the service with the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/missions/missions.service.ts",title:"src/missions/missions.service.ts"},"import { Injectable } from '@nestjs/common';\n\nexport interface Mission {\n  id?: number;\n  description: string;\n  complete: boolean;\n}\n\nconst defaultMission: Mission = {\n  id: 1,\n  description: 'save the galaxy',\n  complete: false,\n};\n\n@Injectable()\nexport class MissionsService {\n  missions: Mission[] = [{ ...defaultMission }];\n\n  getList() {\n    return this.missions;\n  }\n}\n")),(0,i.kt)("p",null,"Above, we first define a ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," interface that will be the data structure for\nthe missions. It will have an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," with an optional type of number, a\n",(0,i.kt)("inlineCode",{parentName:"p"},"description")," with a type of string, a ",(0,i.kt)("inlineCode",{parentName:"p"},"complete")," with a type of boolean, and a\n",(0,i.kt)("inlineCode",{parentName:"p"},"created")," with a type of string that will contain an ISO date string of when the mission was added."),(0,i.kt)("p",null,"Next, we define a default mission we will use to seed the database.\nSpeaking of databases, to keep things simple, we won't be using a real one here. Instead, we'll be using an in-memory array that I'll lovingly refer to as\nArrayDB\u2122\ufe0f. Therefore, each time we update the Nest app and it\nrecompiles/relaunches, we'll lose any modifications. Thus, we'll set the array\nto contain the ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultMission")," when the service initializes. In a real app, we\nwould instead call into a data layer or ORM like ",(0,i.kt)("a",{parentName:"p",href:"https://typeorm.io/"},"TypeORM"),"\nor ",(0,i.kt)("a",{parentName:"p",href:"https://www.prisma.io/"},"Prisma")," to manage data."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"getList()")," method returns everything currently in the array."),(0,i.kt)("p",null,"Next, update the controller to get a reference to the service via\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/fundamentals/custom-providers#di-fundamentals"},"dependency injection"),"\n(just like Angular!). Then, update the ",(0,i.kt)("inlineCode",{parentName:"p"},"getList")," method to return the call from\nthe service instead of the hard-coded array:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, Get } from '@nestjs/common';\nimport { MissionsService } from './missions.service';\n\n@Controller('missions')\nexport class MissionsController {\n  constructor(private missionsService: MissionsService) {}\n\n  @Get()\n  getList() {\n    return this.missionsService.getList();\n  }\n}\n")),(0,i.kt)("p",null,'Now we can rerun the test, and if we see the description of the mission come\nback as "save the galaxy" (versus "save the world"), we know the API is\nreturning data back from the service.'),(0,i.kt)("h2",{id:"get-single-mission"},"Get Single Mission"),(0,i.kt)("p",null,"Next, let's update the API to be able to retrieve a specific mission via its\n",(0,i.kt)("inlineCode",{parentName:"p"},"id"),". We'll specify the id via a route param appended to the end of the URL like\n'/missions/1'."),(0,i.kt)("p",null,"First, add a test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"it('should get single mission', () => {\n  cy.api('/missions/1').as('response');\n  cy.get('@response').its('status').should('equal', 200);\n  cy.get('@response').its('body').should('include', {\n    id: 1,\n    description: 'take out the trash',\n    complete: false,\n  });\n});\n")),(0,i.kt)("p",null,"This test starts much like the last one, except we specify we want to pull\nback the mission with the id of 1 (the default mission). After we assert the\nrequest comes back successfully (by ensuring the status code is 200), we check\nthat the response's body includes the mission we expect."),(0,i.kt)("p",null,"Update the service to add a get method, which will use ArrayDB\u2122\ufe0f's find method\nto retrieve the mission if it exists, else it will just return undefined:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.service.ts",title:"missions.service.ts"},"get(id: number) {\n  const mission = this.missions.find(x => x.id === id);\n  return mission;\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.controller.ts",title:"missions.controller.ts"},"@Get(':id')\nget(@Param('id', ParseIntPipe) id: number) {\n  return this.missionsService.get(id);\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'ParseIntPipe is imported from "@nestjs/common"')),(0,i.kt)("p",null,"Let's go over what's new here. First, the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Get()")," decorator is taking in a\nstring param, which is an additional path in the URL that the controller should\nlook for in addition to the URL prefix that's supplied in the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Controller()"),'\ndecorator in the class. Here, we are specifying ":id". When we prepend a colon\nto the string like we did, we are saying we are looking for a dynamic portion of\nthe string, and when matched, store it in a variable that is named by what\ncomes after the colon.'),(0,i.kt)("p",null,'In our case, we are going to store the mission id (as our path is\n/missions/{id}), into a variable named "id". In the ',(0,i.kt)("inlineCode",{parentName:"p"},"get()")," method, we have a\nmethod argument named ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", but before it, we are using the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Param()")," decorator.\nThis decorator instructs Nest to look for the variable name passed into it and\nbind it to the argument."),(0,i.kt)("p",null,"Since parameters coming in from the URL are all strings, we can use a mechanism\nbuilt into Nest known as ",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/pipes"},"pipes")," to transform the\nvalue on the way in. Above, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ParseIntPipe")," to convert the value to a\nnumber, which our service will need when looking up the mission."),(0,i.kt)("p",null,"Next, let's add a test that shows when we request a mission that doesn't exist,\nthe API should return a 404 not found error. We'll do so by passing in\nan id of 100 to the missions endpoint:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"it('should throw 404 if single mission is not found', () => {\n  cy.api({\n    url: '/missions/100',\n    failOnStatusCode: false,\n  }).as('response');\n  cy.get('@response').its('status').should('equal', 404);\n});\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"By default, calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.api()")," will fail if they don't return a success\nstatus code in the 200 range. Above, we expect the code to be 404, so\nwe turn ",(0,i.kt)("inlineCode",{parentName:"p"},"failOnStatusCode")," to false in the options so it won't fail.")),(0,i.kt)("p",null,"If you run the test, you will see it currently fails. Even though we don't get a\nmission back, the status code is 200."),(0,i.kt)("p",null,"Nest provides a\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/exception-filters#built-in-http-exceptions"},"set of exceptions"),"\nthat we can throw in certain scenarios to return back appropriate status codes.\nOne of which is the ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundException"),". We can throw this error anywhere in the app, and a global exception filter will catch it and return back a\nresponse with a 404 status code."),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsService"),", we will check to see if we find a mission when we\nquery ArrayDB\u2122\ufe0f for it. If we don't, we'll throw a ",(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundException")," and let\nNest handles the dirty work from there:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"get(id: number) {\n  const mission = this.missions.find((x) => x.id === id);\n  if (!mission) {\n    throw new NotFoundException();\n  }\n  return mission;\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"NotFoundException"),' is imported from "@nestjs/common"')),(0,i.kt)("h2",{id:"add-mission"},"Add Mission"),(0,i.kt)("p",null,"Next up, let's add new missions to the list. To add a mission, we will use the\n\"POST\" HTTP method to the missions endpoint, and set the request's body\nwith the new mission. We'll expect the result of the API request to be the new\nmission created."),(0,i.kt)("p",null,"Add the following test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"it('can add mission', () => {\n  const mission = {\n    description: 'test mission',\n    complete: false,\n  };\n  cy.api('POST', '/missions', mission).as('response');\n  cy.get('@response').its('status').should('equal', 201);\n  cy.get('@response').its('body').should('include', mission);\n});\n")),(0,i.kt)("p",null,"The only thing we haven't seen above is passing the new mission as an\nobject to the third parameter of the ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.api()")," method. The method will\nserialize the object as JSON and set it to the request's body, as well as set\nall the necessary headers."),(0,i.kt)("p",null,"Update the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsService")," to include the ",(0,i.kt)("inlineCode",{parentName:"p"},"addMission")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"add(mission: Mission) {\n  const newId = Math.max(...this.missions.map((x) => x.id)) + 1;\n  mission.id = newId;\n  this.missions.push(mission);\n  return mission;\n}\n")),(0,i.kt)("p",null,"Here, we take the new mission, and since ArrayDB\u2122\ufe0f doesn't have\nauto-incrementing ids, we need to calculate a new id on our own. After that, we\nuse the push method to add the new mission to the list and then return it."),(0,i.kt)("p",null,"Next, add the controller method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=mission.controller.ts",title:"mission.controller.ts"},"@Post()\naddMission(@Body() mission: Mission) {\n  return this.missionsService.add(mission);\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Post and Body are imported from "@nestjs/common"')),(0,i.kt)("p",null,"There are a couple of new things to note above. First, the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Post()"),' decorator\nstates that this will be the method that will response to "POST" HTTP methods.'),(0,i.kt)("p",null,"Next is the new ",(0,i.kt)("inlineCode",{parentName:"p"},"@Body()")," decorator. This instructs Nest to take the contents\nfrom the body of the request and serialize it into the parameter it is attached\nto. Hence, the mission variable will contain the new mission to add."),(0,i.kt)("p",null,"Run the add mission test again, and you should see it pass with a 201 status\ncode, which represents a new entity created due to the request."),(0,i.kt)("h2",{id:"update--delete-missions"},"Update & Delete Missions"),(0,i.kt)("p",null,"Now that we are starting to get the hang of this let's bang out the last two\nmethods we are going to want: updating and deleting."),(0,i.kt)("p",null,"First, the tests:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"it('should update mission', () => {\n  const mission = {\n    description: 'get cat out of tree',\n    complete: true,\n  };\n  cy.api({\n    url: '/missions/1',\n    method: 'PUT',\n    body: mission,\n  }).as('response');\n  cy.get('@response').its('status').should('equal', 200);\n  cy.get('@response').its('body').should('include', mission);\n});\n\nit('can delete mission', () => {\n  cy.api('DELETE', '/missions/1').as('response');\n  cy.get('@response').its('status').should('equal', 204);\n});\n")),(0,i.kt)("p",null,"The service code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.service.ts",title:"missions.service.ts"},"update(id: number, mission: Mission) {\n  mission.id = id;\n  this.missions = this.missions.map((x) => {\n    return x.id === id ? mission : x;\n  });\n  return this.get(id);\n}\n\ndelete(id: number) {\n  this.missions = this.missions.filter((x) => x.id !== id);\n}\n")),(0,i.kt)("p",null,"And the controller code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.controller.ts",title:"missions.controller.ts"},"@Put(':id')\nupdateMission(\n  @Param('id', ParseIntPipe) id: number,\n  @Body() mission: Mission,\n) {\n  return this.missionsService.update(id, mission);\n}\n\n@Delete(':id')\n@HttpCode(204)\ndelete(@Param('id', ParseIntPipe) id: number) {\n  this.missionsService.delete(id);\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Put, Delete, and HttpCode are imported from "@nestjs/common"')),(0,i.kt)("p",null,"Pretty standard stuff that you've seen already. The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Put()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@Delete()"),"\ndecorators make these methods listen for their respective HTTP methods."),(0,i.kt)("p",null,"The only new thing is the ",(0,i.kt)("inlineCode",{parentName:"p"},"@HttpCode()")," decorator on the ",(0,i.kt)("inlineCode",{parentName:"p"},"delete()"),' method. By\ndefault, Nest will return back a 200 status code for all HTTP methods except for\n"POST", which it will return 201 for. To change the default, use this decorator.\nIn our case, we are using status code 204, which means we are not returning any\ncontent, and that is to be expected. Notice how we are not returning anything\nfrom this method.'),(0,i.kt)("p",null,"The first time we run these tests, they will pass. However, on the next run, we will\nget some failures. This is because some tests expect the database\nto be in its default state, but we are now modifying it with the add, update,\nand delete methods."),(0,i.kt)("p",null,"It is best practice to not have one test reflect the outcomes of another test,\nbut that is exactly what we are doing currently. What can we do about it?"),(0,i.kt)("p",null,"One method is resetting the database into a known state before running each test.\nThis is often difficult to do, but we have that luxury because our database is so small. Let's see how we can accomplish that."),(0,i.kt)("h2",{id:"seeding-the-database"},"Seeding the Database"),(0,i.kt)("p",null,"The technique we are going to use here is having a method in our API that will\nreset the database back to its initial state. The first thing we will do is have\na method in the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissionsService")," to reset the ArrayDB\u2122\ufe0f:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.service.ts",title:"missions.service.ts"},"reset() {\n  this.missions = [{ ...defaultMission }];\n}\n")),(0,i.kt)("p",null,"Above, we are overriding the array by setting it to an array that only\ncontains the ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultMission"),", just like when the API first initializes."),(0,i.kt)("p",null,"Next, we'll create a method in the controller our tests can call to reset:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.controller.ts",title:"missions.controller.ts"},"@Post('/reset')\nreset() {\n  if (process.env.NODE_ENV === 'test' || process.env.NODE_ENV === 'dev') {\n    this.missionsService.reset();\n  }\n}\n")),(0,i.kt)("p",null,'We\'ll make the method respond to a "POST" request since its changing state\ninside the system. We also check to ensure that the environment is either\n"test" or "dev", as we don\'t want to call this method available in production.\nWe need to update the "start:dev" script in the package file to set the Node\nenvironment.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:"package.json","package.json":!0},'"start:dev": "NODE_ENV=dev nest start --watch",\n')),(0,i.kt)("p",null,"Make sure you restart the Nest server so the change can take effect."),(0,i.kt)("p",null,"A bit later, we will take a look at how to secure this endpoint even more so that the\ncalling API will need a token to call it."),(0,i.kt)("p",null,"In the tests, we want to ensure that we reseed the database before each\ntest is run. We can use the\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/core-concepts/writing-and-organizing-tests#Test-Structure"},(0,i.kt)("inlineCode",{parentName:"a"},"beforeEach")),"\ntest hook for that. Add the following block inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"describe")," block before\nthe first test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"beforeEach(() => {\n  cy.request({\n    log: false,\n    method: 'POST',\n    url: '/missions/reset',\n  });\n  cy.log('seeding db');\n});\n")),(0,i.kt)("p",null,"Above, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cy.request()")," command, the built-in command for\nmaking API requests in Cypress. We set logging to false so it doesn't get too\nnoisy in the command log, but we also output a small \"seeding db\" message, so we can see it's happening."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The technique above is just one strategy for seeding a database for testing,\nthere are many ways to do so, and some will be more appropriate for others in\nyour app. See the Cypress guide on\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.cypress.io/guides/end-to-end-testing/testing-your-app#Seeding-data"},"seeding data"),"\nfor some more info on the subject.")),(0,i.kt)("p",null,"Now you should be able to run the tests over and over again without the state of\nthe previous test is getting in the way."),(0,i.kt)("h2",{id:"protecting-routes"},"Protecting Routes"),(0,i.kt)("p",null,"Above, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()")," method on the controller, we put one safeguard in place\nto ensure the app wasn't in production when trying to reseed the database.\nLet's add another layer of security by requiring the calling client to provide a\ntoken to prove they have access to do a db reseed."),(0,i.kt)("p",null,"To accomplish validating this token, we will use a\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/guards"},"Nest Guard"),", which is a piece of middleware\nwhich Nest can invoke for each HTTP request before passing the request on to the\ncontrollers."),(0,i.kt)("p",null,"First, we will use the CLI to create a guard for us. We'll call it\n",(0,i.kt)("inlineCode",{parentName:"p"},"TestEnvOnly"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nest g guard TestEnvOnly\n")),(0,i.kt)("p",null,"A guard is another JavaScript class with one required method, ",(0,i.kt)("inlineCode",{parentName:"p"},"canActivate"),".\nThis method determines if the request should be able to proceed through the\npipeline or not by returning a boolean or a promise/observable that yields a\nboolean value."),(0,i.kt)("p",null,"Update the contents of the newly created\n",(0,i.kt)("strong",{parentName:"p"},"src/test-env-only/test-env-only.guard.ts")," file with the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/test-env-only/test-env-only.guard.ts",title:"src/test-env-only/test-env-only.guard.ts"},"import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class TestEnvOnlyGuard implements CanActivate {\n  canActivate(\n    context: ExecutionContext\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    const request = context.switchToHttp().getRequest();\n\n    if (!(process.env.NODE_ENV === 'test' || process.env.NODE_ENV === 'dev')) {\n      return false;\n    }\n\n    if (request.headers.authorization !== 'resetcreds') {\n      return false;\n    }\n\n    return true;\n  }\n}\n")),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"canActivate")," method, the first thing we do is grab access to the HTTP\nrequest."),(0,i.kt)("p",null,"Next, we move the code to check the environment from the controller ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()"),"\nmethod, and then we check an ",(0,i.kt)("inlineCode",{parentName:"p"},"authorization")," header has the correct token.\nWe are using a simple string here, but this token could be more complex, like a\nJWT or API key that could be validated."),(0,i.kt)("p",null,"If either of the above checks doesn't pass, we return false, instructing Nest\nto end the request and send back a 403 Forbidden status code. We return true if they are both\ngood, and the request will continue to the controller."),(0,i.kt)("p",null,"Unlike when we generated the Nest service and controller, the guard did not\nautomatically get wired up for us in the app module. That's because the way you\nuse guards can either be global or more granular. We only want to apply the\nguard to the ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()")," method, so we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@UseGuards()")," decorator and\npass the ",(0,i.kt)("inlineCode",{parentName:"p"},"TestOnlyGuard")," as a parameter to it:"),(0,i.kt)("p",null,"a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@UseGuards(TestEnvOnlyGuard)\n@Post('/reset')\nreset() {\n  this.missionsService.reset();\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'UseGuards is imported from "@nestjs/common" TestEnvOnlyGuard is imported from\n"src/test-env-only/test-env-only.guard"')),(0,i.kt)("p",null,"Nest will now use the guard for each request coming into this method."),(0,i.kt)("p",null,'If you try the tests again, you will see them fail because we aren\'t passing the\ntoken on the "reset" request in the ',(0,i.kt)("inlineCode",{parentName:"p"},"beforeEach"),". Update the block to do so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"beforeEach(() => {\n  cy.request({\n    log: false,\n    method: 'POST',\n    url: '/missions/reset',\n    headers: {\n      Authorization: 'resetcreds',\n    },\n  });\n  cy.log('seeding db');\n});\n")),(0,i.kt)("p",null,"Visit the Nest docs for more ways to bind guards to your application."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"We use a guard here to protect our database, but you will also use guards to\nimplement authentication to validate who users are. They even include some built-in ones to get you up and running quickly. Visit their\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/security/authentication"},"authentication")," guide for more\ninfo.")),(0,i.kt)("h2",{id:"validation"},"Validation"),(0,i.kt)("p",null,"We have a working API to manage our missions. However, we haven't\ndone anything to ensure that the data coming into our system is valid.\nValidating data coming into your system is important because it helps ensure the integrity of your database, helps with security and provides a better developer\nexperience for those consuming your API."),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," model is fairly simple, but let us add some validation to it to\nensure that any time one is added or updated, we make sure it's good."),(0,i.kt)("p",null,"First up, a new test to validate that trying to create an invalid module returns\na 400 Bad Request status code, which signifies to the user they did\nsomething wrong with the request. The body of the response will contain helpful\nmessages on what went wrong:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.cy.ts",title:"missions.cy.ts"},"it('when adding an invalid mission, get 400 error', () => {\n  const mission = {};\n  cy.api({\n    method: 'POST',\n    url: '/missions',\n    body: mission,\n    failOnStatusCode: false,\n  }).as('response');\n  cy.get('@response').its('status').should('equal', 400);\n  cy.get('@response')\n    .its('body')\n    .should('deep.include', {\n      message: [\n        'description must not be an empty string',\n        'description must be a string',\n        'complete must be a boolean',\n      ],\n    });\n});\n")),(0,i.kt)("p",null,"We will be using a couple of helper libraries to help accomplish this.\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/typestack/class-validator"},"Class Validator")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/typestack/class-transformer"},"Class Transformer")," are two\nlibraries that fit well in the Nest ecosystem. They allow us to use TypeScript\ndecorators to annotate our models and provide validation logic declaratively."),(0,i.kt)("p",null,"We need to install the libraries. Run the following from your terminal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm i class-transformer class-validator\n")),(0,i.kt)("p",null,"Currently, our ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," model is an interface. To annotate it with\ndecorators, we will need to convert it to a class instead and refactor some\ncode."),(0,i.kt)("p",null,"Create a new file at ",(0,i.kt)("strong",{parentName:"p"},"src/missions/Mission.ts")," and paste the following into\nit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/missions/Mission.ts",title:"src/missions/Mission.ts"},"export class Mission {\n  id?: number;\n  description: string;\n  complete: boolean;\n  created: string;\n\n  constructor(partial: Partial<Mission>) {\n    Object.assign(this, partial);\n  }\n}\n")),(0,i.kt)("p",null,"Next, delete the ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," interface from the top of the ",(0,i.kt)("strong",{parentName:"p"},"missions.service.ts"),"\nfile and reference the new class in both the service and controller."),(0,i.kt)("p",null,"And then, to make sure we are using an instance of the class, update where we\ninitialize the missions array in the service, as well as where it gets reset in\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=missions.service.ts",title:"missions.service.ts"},"//initialize missions\nmissions: Mission[] = [new Mission(defaultMission)];\n\n//reset\nreset() {\n  this.missions = [new Mission(defaultMission)];\n}\n")),(0,i.kt)("p",null,"Perfect! Now that we have a class, we can begin to decorate the ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," class\nwith validation functions. We'll verify that ",(0,i.kt)("inlineCode",{parentName:"p"},"description")," is a string and\nis not empty and that complete is a boolean. To do so, we'll use the\n",(0,i.kt)("inlineCode",{parentName:"p"},"@IsString()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"@IsNotEmpty()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"@IsBoolean()")," decorators. Update the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," class and add the validators to the ",(0,i.kt)("inlineCode",{parentName:"p"},"description")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"complete"),"\nproperties:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=Mission.ts",title:"Mission.ts"},"import { IsString, IsNotEmpty, IsBoolean } from 'class-validator';\n\nexport class Mission {\n  id?: number;\n\n  //highlight-start\n  @IsString({ message: 'description must be a string' })\n  @IsNotEmpty({ message: 'description must not be an empty string' })\n  //highlight-end\n  description: string;\n\n  //highlight-next-line\n  @IsBoolean({ message: 'complete must be a boolean' })\n  complete: boolean;\n  created: string;\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'@IsString, IsNotEmpty, and IsBoolean are imported from "class-validator"')),(0,i.kt)("p",null,"Each decorator takes a set of options, and we can set the error message we\nwant to use if the validation fails."),(0,i.kt)("p",null,"Now that the decorators are in place, how do we use them? Nest has\nanother piece of middleware known as ",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/pipes"},"pipes"),"\n(similar to the guards which we used above) whose job is to inspect incoming\nrequests and provide validation and transformation to the request. You can see\nan example of how one is built\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/pipes#class-validator"},"here"),". However, Nest already has\na built-in\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/pipes#the-built-in-validationpipe"},"ValidationPipe"),",\nwhich does exactly what we need it to."),(0,i.kt)("p",null,"We'll want every API request to be run through the ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidationPipe"),", so instead\nof granularly applying it to methods as we did above with ",(0,i.kt)("inlineCode",{parentName:"p"},"@UseGuards()"),",\nwe'll configure it in the app module. Update the ",(0,i.kt)("strong",{parentName:"p"},"src/app.module.ts")," file to\nadd a new item in the providers array:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/app.module.ts",title:"src/app.module.ts"},"@Module({\n  imports: [],\n  controllers: [AppController, MissionsController],\n  providers: [\n    AppService,\n    MissionsService,\n    //highlight-start\n    {\n      provide: APP_PIPE,\n      useValue: new ValidationPipe({ transform: true }),\n    },\n    //highlight-end\n  ],\n})\nexport class AppModule {}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'APP_PIPE is imported from "@nestjs/core" and ValidationPipe is imported from\n"@nestjs/common"')),(0,i.kt)("p",null,"This will instruct Nest that anytime a request is made to run the request\nthrough ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidationPipe"),", which will parse the request body, convert it to an instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," class, and run any validators on it through\n",(0,i.kt)("inlineCode",{parentName:"p"},"class-validator"),". If validation fails, then it will return back a 400 status\ncode."),(0,i.kt)("p",null,"With all that in place, our test should now pass."),(0,i.kt)("p",null,"You might have noticed that we passed in ",(0,i.kt)("inlineCode",{parentName:"p"},"{transform: true}")," as an option to the\n",(0,i.kt)("inlineCode",{parentName:"p"},"ValidationPipe")," class. This will convert any values to how they are typed in\nTypeScript on its way in. This means that we can now remove any of those\n",(0,i.kt)("inlineCode",{parentName:"p"},"ParseIntPipes")," were being used to convert the ids into strings. Go ahead\nand do so and you'll see that all the tests still pass!"),(0,i.kt)("h2",{id:"exclude-properties"},"Exclude properties"),(0,i.kt)("p",null,"Okay, one last cool trick to show you before we wrap up is introducing\nthe concept of ",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/interceptors"},"Nest Interceptors"),". An\ninterceptor is another piece of specialized middleware, and its purpose is to\ntransform any responses on their way out (opposite of a pipe)."),(0,i.kt)("p",null,"In our ",(0,i.kt)("inlineCode",{parentName:"p"},"Mission")," class, we've had the created date that shows when the mission\nwas added. Let's pretend this info is only somewhat valuable to the clients of\nthe API, and we want to remove it before it gets sent out."),(0,i.kt)("p",null,"Add another check to the 'should get single mission' test to make sure the\nthe property comes back undefined:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"it('should get single mission', () => {\n  cy.api('/missions/1').as('response');\n  cy.get('@response').its('status').should('equal', 200);\n  cy.get('@response').its('body').should('include', {\n    id: 1,\n    description: 'save the galaxy',\n    complete: false,\n  });\n  //highlight-next-line\n  cy.get('@response').its('body.created').should('be.undefined');\n});\n")),(0,i.kt)("p",null,"The test will currently fail because ",(0,i.kt)("inlineCode",{parentName:"p"},"created")," comes back."),(0,i.kt)("p",null,"To exclude the property, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Exclude()")," decorator from\n",(0,i.kt)("inlineCode",{parentName:"p"},"class-transformer"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=Mission.ts",title:"Mission.ts"},"@Exclude()\ncreate: string;\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Exclude is imported from "class-transformer"')),(0,i.kt)("p",null,"When a class is run through ",(0,i.kt)("inlineCode",{parentName:"p"},"class-validator"),", it will convert the object into a\nplain JavaScript object and run any transformations on it (such as excluding\nproperties). We can use the the built-in\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/techniques/serialization"},(0,i.kt)("inlineCode",{parentName:"a"},"ClassSerializerInterceptor")),"\nfrom Nest to do this for us."),(0,i.kt)("p",null,"To use the interceptor, add another provider to the app module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=app.module.ts",title:"app.module.ts"},"providers: [\n  AppService,\n  MissionsService,\n  {\n    provide: APP_PIPE,\n    useValue: new ValidationPipe({ transform: true }),\n  },\n  //highlight-start\n  {\n    provide: APP_INTERCEPTOR,\n    useClass: ClassSerializerInterceptor,\n  },\n  //highlight-end\n],\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'APP_INTERCEPTOR is imported from "@nestjs/core" and ClassSerializerInterceptor\nis imported from "@nestjs/common"')),(0,i.kt)("p",null,"Now the 'should get single mission' test should pass again."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Thanks for taking the time to work through this tutorial. Hopefully, I showed\nyou how to get up and running with Nest quickly and how to use Cypress with the\nCypress API Plugin as a development aid while building out your API. The extra benefit is that you also have a set of repeatable tests to run to\nensure your API functions as it should."),(0,i.kt)("p",null,"Feel free to hit me up on Twitter ",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/elylucas"},"@elylucas")," if you have any questions."),(0,i.kt)("p",null,"Happy Coding!"))}c.isMDXComponent=!0},8124:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/missions_fail-a136ff53c9d432e64b1c7ea01ab2672c.jpg"},7546:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/run_all_tests-9bab9f0223002d2b67dd40d8278311fa.jpg"}}]);